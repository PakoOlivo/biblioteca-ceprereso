/**
 * DEMOSTRACI√ìN COMPLETA DEL SISTEMA DE IDs AUTOM√ÅTICOS PARA LIBROS
 * 
 * Este script demuestra todas las caracter√≠sticas implementadas:
 * ‚úÖ Generaci√≥n autom√°tica de IDs en formato Estante+Nivel+Posici√≥n
 * ‚úÖ Detecci√≥n y reutilizaci√≥n de espacios vacantes
 * ‚úÖ Gesti√≥n de estados (disponible/dado_de_baja)
 * ‚úÖ Generaci√≥n de c√≥digos de barras para etiquetas
 * ‚úÖ Listado de espacios vacantes
 */

// Mock Database (simulaci√≥n para demo) - Singleton
class MockDatabase {
  constructor() {
    if (MockDatabase.instance) {
      return MockDatabase.instance;
    }
    
    this.libros = [
      { id: 'A101', titulo: 'El Principito', autor: 'Antoine de Saint-Exup√©ry', estante: 'A', nivel: 1, posicion: 1, estado: 'disponible' },
      { id: 'A102', titulo: 'Cien a√±os de soledad', autor: 'Gabriel Garc√≠a M√°rquez', estante: 'A', nivel: 1, posicion: 2, estado: 'disponible' },
      { id: 'A104', titulo: 'Don Quijote', autor: 'Miguel de Cervantes', estante: 'A', nivel: 1, posicion: 4, estado: 'disponible' },
      { id: 'B201', titulo: 'La Odisea', autor: 'Homero', estante: 'B', nivel: 2, posicion: 1, estado: 'dado_de_baja' },
      { id: 'C301', titulo: 'Romeo y Julieta', autor: 'William Shakespeare', estante: 'C', nivel: 3, posicion: 1, estado: 'dado_de_baja' },
    ];
    
    MockDatabase.instance = this;
    console.log('üìö Base de datos inicializada con libros de ejemplo\n');
  }

  async select(query, params = []) {
    if (query.includes('COUNT(*)')) {
      return [{ count: this.libros.length }];
    }
    
    if (query.includes('SELECT posicion FROM libros WHERE estante')) {
      const [estante, nivel, estado] = params;
      const ocupadas = this.libros
        .filter(libro => libro.estante === estante && libro.nivel === nivel && libro.estado !== estado)
        .map(libro => ({ posicion: libro.posicion }));
      return ocupadas;
    }
    
    if (query.includes('SELECT id FROM libros WHERE estante')) {
      const [estante, nivel, posicion, estado] = params;
      const existe = this.libros
        .filter(libro => 
          libro.estante === estante && 
          libro.nivel === nivel && 
          libro.posicion === posicion && 
          libro.estado !== estado
        );
      return existe;
    }
    
    if (query.includes('SELECT DISTINCT estante, nivel, posicion, id')) {
      let filtered = this.libros.filter(libro => libro.estado === 'dado_de_baja');
      if (params[0]) filtered = filtered.filter(libro => libro.estante === params[0]);
      if (params[1] !== undefined) filtered = filtered.filter(libro => libro.nivel === params[1]);
      return filtered;
    }

    if (query.includes('SELECT id, titulo, autor FROM libros WHERE id')) {
      const libro = this.libros.find(l => l.id === params[0]);
      return libro ? [{ id: libro.id, titulo: libro.titulo, autor: libro.autor }] : [];
    }
    
    return this.libros;
  }

  async execute(query, params = []) {
    if (query.includes('INSERT INTO libros')) {
      const [id, titulo, autor, genero, estante, nivel, posicion, ubicacion] = params;
      this.libros.push({
        id, titulo, autor, genero, estante, nivel, posicion, ubicacion, estado: 'disponible'
      });
    } else if (query.includes('UPDATE libros SET estado')) {
      const [estado, id] = params;
      const libro = this.libros.find(l => l.id === id);
      if (libro) libro.estado = estado;
    }
    return { changes: 1 };
  }

  static async load(dbPath) {
    if (!MockDatabase.instance) {
      MockDatabase.instance = new MockDatabase();
    }
    return MockDatabase.instance;
  }
}

// Funciones del sistema de IDs (versi√≥n demo)
async function generarIdLibro(estante, nivel, posicion) {
  const db = await MockDatabase.load('sqlite:db_biblioteca.db');
  
  if (posicion === undefined) {
    const ocupadas = await db.select(
      'SELECT posicion FROM libros WHERE estante = ? AND nivel = ? AND estado != ? ORDER BY posicion',
      [estante.toUpperCase(), nivel, 'dado_de_baja']
    );
    
    let posicionDisponible = 1;
    const posicionesOcupadas = ocupadas.map(row => row.posicion).sort((a, b) => a - b);
    
    for (const pos of posicionesOcupadas) {
      if (pos === posicionDisponible) {
        posicionDisponible++;
      } else {
        break;
      }
    }
    
    posicion = posicionDisponible;
  }
  
  const yaExiste = await db.select(
    'SELECT id FROM libros WHERE estante = ? AND nivel = ? AND posicion = ? AND estado != ?',
    [estante.toUpperCase(), nivel, posicion, 'dado_de_baja']
  );
  
  if (yaExiste.length > 0) {
    throw new Error(`La posici√≥n ${estante.toUpperCase()}${nivel}${posicion.toString().padStart(2, '0')} ya est√° ocupada`);
  }
  
  const id = `${estante.toUpperCase()}${nivel}${posicion.toString().padStart(2, '0')}`;
  return id;
}

async function listarEspaciosVacantes(estante, nivel) {
  const db = await MockDatabase.load('sqlite:db_biblioteca.db');
  
  let query = `SELECT DISTINCT estante, nivel, posicion, id FROM libros WHERE estado = 'dado_de_baja'`;
  const params = [];
  
  if (estante) {
    query += ' AND estante = ?';
    params.push(estante.toUpperCase());
  }
  
  if (nivel !== undefined) {
    query += ' AND nivel = ?';
    params.push(nivel);
  }
  
  query += ' ORDER BY estante, nivel, posicion';
  
  return await db.select(query, params);
}

async function registrarLibro(datos) {
  const db = await MockDatabase.load('sqlite:db_biblioteca.db');
  const id = await generarIdLibro(datos.estante, datos.nivel, datos.posicion);
  const posicionFinal = parseInt(id.slice(-2));
  const ubicacion = `Estante ${datos.estante.toUpperCase()}-${datos.nivel}-${posicionFinal.toString().padStart(2, '0')}`;
  
  await db.execute(
    `INSERT INTO libros (id, titulo, autor, genero, estante, nivel, posicion, ubicacion, estado) VALUES (?, ?, ?, ?, ?, ?, ?, ?, 'disponible')`,
    [id, datos.titulo, datos.autor || '', datos.genero || '', datos.estante.toUpperCase(), datos.nivel, posicionFinal, ubicacion]
  );
  
  return id;
}

async function darDeBajaLibro(id) {
  const db = await MockDatabase.load('sqlite:db_biblioteca.db');
  const libro = await db.select('SELECT id, estado FROM libros WHERE id = ?', [id]);
  
  if (libro.length === 0) {
    throw new Error(`No se encontr√≥ el libro con ID: ${id}`);
  }
  
  if (libro[0].estado === 'dado_de_baja') {
    throw new Error(`El libro con ID: ${id} ya est√° dado de baja`);
  }
  
  await db.execute('UPDATE libros SET estado = ? WHERE id = ?', ['dado_de_baja', id]);
}

function generarCodigoBarras(idLibro) {
  const barras = idLibro
    .split('')
    .map(char => {
      const codigo = char.charCodeAt(0);
      return '|'.repeat(codigo % 5 + 1) + ' '.repeat(2);
    })
    .join('');
  
  return `|||| ${barras} ||||`;
}

async function exportarCodigoBarrasLibro(idLibro) {
  const db = await MockDatabase.load('sqlite:db_biblioteca.db');
  const libro = await db.select('SELECT id, titulo, autor FROM libros WHERE id = ?', [idLibro]);
  
  if (libro.length === 0) {
    throw new Error(`No se encontr√≥ el libro con ID: ${idLibro}`);
  }
  
  const codigoBarras = generarCodigoBarras(idLibro);
  
  return `
ID: ${idLibro}
T√≠tulo: ${libro[0].titulo}
Autor: ${libro[0].autor}

${codigoBarras}
  `.trim();
}

// DEMOSTRACI√ìN COMPLETA
async function demoCompleto() {
  console.log('üéØ DEMOSTRACI√ìN COMPLETA - SISTEMA DE IDs AUTOM√ÅTICOS PARA LIBROS');
  console.log('‚ïê'.repeat(70));
  console.log('');
  
  try {
    // 1. Estado inicial
    console.log('üìä 1. ESTADO INICIAL DEL SISTEMA');
    console.log('‚îÄ'.repeat(40));
    const db = await MockDatabase.load('sqlite:db_biblioteca.db');
    const librosIniciales = await db.select('SELECT * FROM libros');
    console.log('Libros registrados:');
    librosIniciales.forEach(libro => {
      const estado = libro.estado === 'disponible' ? '‚úÖ' : '‚ùå';
      console.log(`  ${estado} ${libro.id} - ${libro.titulo} (${libro.autor})`);
    });
    
    // 2. Mostrar espacios vacantes iniciales
    console.log('\nüîç 2. ESPACIOS VACANTES DETECTADOS');
    console.log('‚îÄ'.repeat(40));
    const espaciosIniciales = await listarEspaciosVacantes();
    if (espaciosIniciales.length > 0) {
      espaciosIniciales.forEach(espacio => {
        console.log(`  üì¶ ${espacio.id} - Estante ${espacio.estante}, Nivel ${espacio.nivel}, Posici√≥n ${espacio.posicion}`);
      });
    } else {
      console.log('  ‚ÑπÔ∏è  No hay espacios vacantes disponibles');
    }
    
    // 3. Registrar nuevo libro - ID autom√°tico
    console.log('\nüìö 3. REGISTRO DE LIBRO CON ID AUTOM√ÅTICO');
    console.log('‚îÄ'.repeat(40));
    console.log('Registrando: "1984" por George Orwell en Estante A, Nivel 1...');
    const id1 = await registrarLibro({
      titulo: '1984',
      autor: 'George Orwell',
      genero: 'Distop√≠a',
      estante: 'A',
      nivel: 1
      // No especificamos posici√≥n - debe ser autom√°tica
    });
    console.log(`‚úÖ Libro registrado con ID: ${id1} (posici√≥n detectada autom√°ticamente)`);
    
    // 4. Registrar libro en espacio vacante
    console.log('\n‚ôªÔ∏è  4. REUTILIZACI√ìN DE ESPACIO VACANTE');
    console.log('‚îÄ'.repeat(40));
    console.log('Registrando libro en espacio vacante B201...');
    const id2 = await registrarLibro({
      titulo: 'Moby Dick',
      autor: 'Herman Melville',
      genero: 'Aventura',
      estante: 'B',
      nivel: 2,
      posicion: 1 // Reutilizar el espacio B201 que estaba dado de baja
    });
    console.log(`‚úÖ Libro registrado con ID: ${id2} (reutiliz√≥ espacio vacante)`);
    
    // 5. Dar de baja un libro
    console.log('\n‚ùå 5. PROCESO DE BAJA DE LIBRO');
    console.log('‚îÄ'.repeat(40));
    console.log('Dando de baja el libro A102...');
    await darDeBajaLibro('A102');
    console.log('‚úÖ Libro A102 dado de baja - espacio ahora disponible');
    
    // 6. Mostrar espacios vacantes actualizados
    console.log('\nüîÑ 6. ESPACIOS VACANTES ACTUALIZADOS');
    console.log('‚îÄ'.repeat(40));
    const espaciosActualizados = await listarEspaciosVacantes();
    espaciosActualizados.forEach(espacio => {
      console.log(`  üì¶ ${espacio.id} - Estante ${espacio.estante}, Nivel ${espacio.nivel}, Posici√≥n ${espacio.posicion}`);
    });
    
    // 7. Generar c√≥digos de barras
    console.log('\nüìä 7. GENERACI√ìN DE C√ìDIGOS DE BARRAS');
    console.log('‚îÄ'.repeat(40));
    const librosActivos = [id1, id2, 'A101'];
    for (const idLibro of librosActivos) {
      console.log(`\nC√≥digo de barras para ${idLibro}:`);
      const etiqueta = await exportarCodigoBarrasLibro(idLibro);
      console.log('‚îå' + '‚îÄ'.repeat(40) + '‚îê');
      etiqueta.split('\n').forEach(linea => {
        console.log('‚îÇ ' + linea.padEnd(38) + ' ‚îÇ');
      });
      console.log('‚îî' + '‚îÄ'.repeat(40) + '‚îò');
    }
    
    // 8. Resumen final
    console.log('\nüìã 8. RESUMEN FINAL');
    console.log('‚îÄ'.repeat(40));
    const librosFinales = await db.select('SELECT * FROM libros');
    const disponibles = librosFinales.filter(l => l.estado === 'disponible').length;
    const dadosDeBaja = librosFinales.filter(l => l.estado === 'dado_de_baja').length;
    
    console.log(`üìö Total de libros: ${librosFinales.length}`);
    console.log(`‚úÖ Libros disponibles: ${disponibles}`);
    console.log(`‚ùå Libros dados de baja: ${dadosDeBaja}`);
    console.log(`üì¶ Espacios vacantes: ${espaciosActualizados.length}`);
    
    console.log('\nüéâ DEMOSTRACI√ìN COMPLETADA EXITOSAMENTE');
    console.log('‚ïê'.repeat(70));
    
    console.log('\n‚ú® CARACTER√çSTICAS IMPLEMENTADAS:');
    console.log('  ‚úÖ Generaci√≥n autom√°tica de IDs (formato: EstanteNivelPosici√≥n)');
    console.log('  ‚úÖ Detecci√≥n inteligente de espacios vacantes');
    console.log('  ‚úÖ Reutilizaci√≥n autom√°tica de posiciones liberadas');
    console.log('  ‚úÖ Gesti√≥n de estados de libros (disponible/dado_de_baja)');
    console.log('  ‚úÖ Generaci√≥n de c√≥digos de barras para etiquetas');
    console.log('  ‚úÖ Listado y consulta de espacios disponibles');
    console.log('  ‚úÖ Validaci√≥n y prevenci√≥n de duplicados');
    
  } catch (error) {
    console.error('‚ùå Error en la demostraci√≥n:', error.message);
  }
}

// Ejecutar demostraci√≥n
demoCompleto();